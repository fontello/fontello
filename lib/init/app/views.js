// `views` section processor
//


'use strict';


/*global underscore, N*/


// stdlib
var fs    = require('fs');
var path  = require('path');


// 3rd-party
var _       = underscore;
var async   = require('async');
var fstools = require('fs-tools');


// internal
var safePropName  = require('./utils/safe_prop_name');
var stopwatch     = require('./utils/stopwatch');
var expandTree    = require('./utils/expand_tree');
var engines       = require('./views/engines');


////////////////////////////////////////////////////////////////////////////////


//  buildClientTree(views[, namespace = 'this.views']) -> String
//  - views (Object): Views map generated by [[Views.collect]].
//  - namespace (String): Global object used as container for the tree.
//
//  Returns a browserified function that will create views tree and will
//  inject it into the `namespace`.
//
//
//  ##### Example
//
//      collect('/path/to/views', function (err, views) {
//        // ...
//        var output = buildClientTree(views, 'this.appViews');
//        fs.writeFile('/path/to/client.js', output);
//        // ...
//      });
//
function buildClientTree(views, namespace) {
  var keys = _.keys(views), head = [], body = [];

  //
  // generate structure needed to build the tree
  //

  keys.forEach(function (api) {
    var parts = api.split('.').map(safePropName);

    // the last element is the function itself, so skip it
    parts.pop();

    while (parts.length) {
      head.push('this' + parts.join(''));
      parts.pop();
    }
  });

  head = _.uniq(head.sort(), true).map(function (ns) {
    return 'if (!' + ns + ') { ' + ns + ' = {}; }';
  });

  //
  // generate tree population with functions
  //

  keys.sort().forEach(function (api) {
    body.push('this' + api.split('.').map(safePropName).join('') +
              ' = ' + views[api].client);
  });

  //
  // Return tree populator
  //


  namespace = namespace || 'this.views';

  return  '(function () {\n' +
          head.join('\n') + '\n' + body.join('\n') +
          '\n}.call(' + namespace + ' || (' + namespace + ' = {})));';
}


//  writeClientTree(filename, views[, namespace], callback(err)) -> String
//  - filename (String): Filename where to write built views tree.
//  - views (Object): Views map generated by [[Views.collect]].
//  - namespace (String): Global object used as container for the tree.
//  - callback (Function): Executed once everything is done.
//
//  Build client-side `views` tree populator and writes it into the `filename`
//  creating parent directories if needed.
//
//
//  ##### Example
//
//      collect('/path/to/views', function (err, views) {
//        // ...
//        writeClientTree('/path/to/client.js', views, function (err) {
//          // ... syntax sugar is sweet ...
//        });
//      });
//
function writeClientTree(filename, tree, namespace, callback) {
  if (!callback) {
    callback  = namespace;
    namespace = null;
  }

  fstools.mkdir(path.dirname(filename), function (err) {
    var str;

    if (err) {
      callback(err);
      return;
    }

    try {
      str = buildClientTree(tree, namespace);
    } catch (err) {
      callback(err);
      return;
    }

    fs.writeFile(filename, str, 'utf8', callback);
  });
}


function processViews(outfile, config, callback) {
  var viewsTree = {};

  async.forEachSeries(config.files, function (pathname, next) {
    var str;

    try {
      str = pathname.readSync();
    } catch (err) {
      next(err);
      return;
    }

    async.parallel([
      function (next) {
        // compile server-side views (functions)
        engines[pathname.extname].server(str, {
          filename: String(pathname)
        }, next);
      },
      function (next) {
        // compile client-side views (string sources of functions)
        engines[pathname.extname].client(str, {
          filename: String(pathname)
        }, next);
      }
    ], function (err, results) {
      // expose compiled data into the tree
      results = results || [];

      viewsTree[pathname.apiPath] = {
        server: results[0],
        client: results[1]
      };

      next(err);
    });
  }, function (err) {
    if (err) {
      callback(err);
      return;
    }

    // Inject server tree
    _.each(viewsTree, function (render, api) {
      N.runtime.views[api] = render.server;
    });

    expandTree(N.runtime.views);

    // write client-side views tree
    writeClientTree(outfile, viewsTree, 'this.N.views', callback);
  });
}


////////////////////////////////////////////////////////////////////////////////


module.exports = function (tmpdir, sandbox, callback) {
  var
  config  = sandbox.config,
  timer   = stopwatch(),
  outdir  = path.join(tmpdir, 'views');

  N.runtime.views = {};

  try {
    fstools.mkdirSync(outdir);
  } catch (err) {
    callback(err);
    return;
  }

  async.forEachSeries(_.keys(config.packages), function (pkgName, next) {
    var
    viewsConfig   = config.packages[pkgName].views,
    viewsOutfile  = path.join(outdir, pkgName + '.js');

    if (!viewsConfig) {
      next();
      return;
    }

    processViews(viewsOutfile, viewsConfig, next);
  }, function (err) {
    N.logger.info('Processed views section ' + timer.elapsed);
    callback(err);
  });
};
